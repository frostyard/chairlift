---
phase: 03-operations-progress
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - internal/window/window.go
  - internal/widgets/action_button.go
autonomous: true

must_haves:
  truths:
    - "Operations button appears in header bar"
    - "ActionButton can register operations with the central registry"
    - "Badge count updates when operations change"
  artifacts:
    - path: "internal/window/window.go"
      provides: "Operations button integrated in header"
      contains: "BuildOperationsButton"
    - path: "internal/widgets/action_button.go"
      provides: "StartTrackedOperation method"
      exports: ["StartTrackedOperation"]
  key_links:
    - from: "internal/window/window.go"
      to: "internal/operations/popover.go"
      via: "BuildOperationsButton call"
      pattern: "operations\\.BuildOperationsButton"
    - from: "internal/widgets/action_button.go"
      to: "internal/operations/registry.go"
      via: "operations.Start call"
      pattern: "operations\\.Start"
---

<objective>
Wire operations button into header and integrate ActionButton with the operations registry.

Purpose: Complete the integration loop - operations are tracked centrally and visible in header popover.
Output: Header shows operations button, ActionButton can register tracked operations.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-operations-progress/03-CONTEXT.md
@.planning/phases/03-operations-progress/03-02-SUMMARY.md
@.planning/phases/03-operations-progress/03-03-SUMMARY.md

@internal/window/window.go
@internal/widgets/action_button.go
@internal/operations/popover.go
@internal/operations/registry.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add operations button to header bar</name>
  <files>
    internal/window/window.go
  </files>
  <action>
Modify `internal/window/window.go` to add the operations button to the sidebar header:

1. Add import for operations package:
```go
import "github.com/frostyard/chairlift/internal/operations"
```

2. Add field to Window struct:
```go
operationsBtn *operations.OperationsButton
```

3. In buildSidebar(), after creating menuButton, add operations button:
```go
// Create operations button (shows ongoing operations)
w.operationsBtn = operations.BuildOperationsButton()
headerBar.PackEnd(&w.operationsBtn.Button.Widget)

// Hamburger menu is already added - operations button goes before it
// So the order will be: [operations] [menu] from left to right on the end
```

Actually, looking at the current code:
```go
headerBar.PackEnd(&menuButton.Widget)
```

The operations button should be packed end BEFORE the menu button so it appears to the left of menu:
```go
// Create operations button first
w.operationsBtn = operations.BuildOperationsButton()
headerBar.PackEnd(&menuButton.Widget)       // Menu rightmost
headerBar.PackEnd(&w.operationsBtn.Button.Widget)  // Operations left of menu
```

Per CONTEXT.md: "Icon always visible in header, badge with count appears when operations are active"
The button is always visible; badge visibility is handled by OperationsButton internally.
  </action>
  <verify>
`go build ./...` succeeds
Run the app and verify operations button appears in sidebar header
  </verify>
  <done>
Operations button appears in sidebar header bar, left of hamburger menu
  </done>
</task>

<task type="auto">
  <name>Task 2: Add StartTrackedOperation to ActionButton</name>
  <files>
    internal/widgets/action_button.go
  </files>
  <action>
Add new method to ActionButton that integrates with operations registry:

```go
// StartTrackedOperation disables the button and registers the operation with the central registry.
//
// This is like StartOperation but also tracks the operation in the global registry,
// making it visible in the operations popover and enabling cancellation.
//
// Parameters:
//   - workingLabel: Label shown while operation runs (e.g., "Installing...")
//   - name: Operation name for registry (e.g., "Install Firefox")
//   - category: Operation category (operations.CategoryInstall, etc.)
//   - cancellable: Whether operation can be cancelled
//
// Returns:
//   - op: The registered operation (caller can call op.UpdateProgress, etc.)
//   - done: Function to call when operation completes (restores button state)
//
// The caller should:
// 1. Call op.UpdateProgress() to update progress
// 2. Call done() when operation completes (always, even on error)
// 3. Call op.Complete(err) to mark operation finished
//
// Must be called from the GTK main thread.
func (ab *ActionButton) StartTrackedOperation(workingLabel, name string, category operations.Category, cancellable bool) (op *operations.Operation, done func())
```

Implementation:
```go
func (ab *ActionButton) StartTrackedOperation(workingLabel, name string, category operations.Category, cancellable bool) (op *operations.Operation, done func()) {
    // Disable button and change label
    ab.Button.SetSensitive(false)
    ab.Button.SetLabel(workingLabel)
    
    // Register with operations registry
    op = operations.Start(name, category, cancellable)
    
    // Create done function that restores button AND completes operation
    return op, func() {
        ab.Button.SetSensitive(true)
        ab.Button.SetLabel(ab.originalLabel)
        // Note: caller still needs to call op.Complete(err) separately
        // This just restores the button state
    }
}
```

Also add import at top:
```go
import "github.com/frostyard/chairlift/internal/operations"
```

Update doc.go to mention StartTrackedOperation as the preferred method for long-running operations that should appear in the operations panel.
  </action>
  <verify>
`go build ./internal/widgets/...` succeeds
  </verify>
  <done>
ActionButton has StartTrackedOperation method that registers with operations.Start() and returns operation + done callback
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./...` succeeds (full build including window.go)
- [ ] Operations button appears in header (can verify by running app)
- [ ] ActionButton has StartTrackedOperation method
- [ ] StartTrackedOperation calls operations.Start internally
- [ ] StartTrackedOperation returns both operation and done function
</verification>

<success_criteria>
- Operations button visible in header bar
- ActionButton can register tracked operations
- Full integration path works: button -> operation -> registry -> popover display
</success_criteria>

<output>
After completion, create `.planning/phases/03-operations-progress/03-04-SUMMARY.md`
</output>
