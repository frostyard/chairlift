---
phase: 03-operations-progress
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/operations/doc.go
  - internal/operations/operation.go
  - internal/operations/registry.go
autonomous: true

must_haves:
  truths:
    - "Operations can be started and tracked with unique IDs"
    - "Operation progress updates are thread-safe"
    - "Operations can transition through states (active, completed, failed, cancelled)"
  artifacts:
    - path: "internal/operations/doc.go"
      provides: "Package documentation explaining threading model"
      min_lines: 20
    - path: "internal/operations/operation.go"
      provides: "Operation struct with lifecycle methods"
      exports: ["Operation", "OperationState", "StateActive", "StateCompleted", "StateFailed", "StateCancelled"]
    - path: "internal/operations/registry.go"
      provides: "Thread-safe registry singleton"
      exports: ["Start", "Get", "ActiveCount", "Active", "History", "AddListener"]
  key_links:
    - from: "internal/operations/registry.go"
      to: "internal/async/scheduler.go"
      via: "RunOnMain for UI listener callbacks"
      pattern: "async\\.RunOnMain"
---

<objective>
Create the operations package core with thread-safe registry and operation lifecycle management.

Purpose: This is the foundation for centralized operation tracking - all future plans depend on these types and registry.
Output: `internal/operations/` package with Operation type, OperationState enum, and Registry singleton.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-operations-progress/03-CONTEXT.md
@.planning/phases/03-operations-progress/03-RESEARCH.md

@internal/async/scheduler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create operations package with doc.go and operation.go</name>
  <files>
    internal/operations/doc.go
    internal/operations/operation.go
  </files>
  <action>
Create `internal/operations/doc.go` with package documentation explaining:
- Purpose: centralized tracking of all async operations
- Threading model: registry is thread-safe, UI updates via async.RunOnMain
- Operation lifecycle: Active -> Completed/Failed/Cancelled

Create `internal/operations/operation.go` with:

```go
type OperationState int

const (
    StateActive OperationState = iota
    StateCompleted
    StateFailed
    StateCancelled
)

type Category string

const (
    CategoryInstall Category = "install"
    CategoryUpdate  Category = "update"
    CategoryLoading Category = "loading"
)

type Operation struct {
    ID          uint64
    Name        string
    Category    Category
    State       OperationState
    StartedAt   time.Time
    EndedAt     time.Time
    Progress    float64         // 0.0-1.0, -1 for indeterminate
    Message     string          // Current status message
    Cancellable bool
    CancelFunc  context.CancelFunc
    Error       error
    RetryFunc   func()          // Called when retry clicked for failed ops
}
```

Add methods on Operation:
- `UpdateProgress(progress float64, message string)` - updates progress, notifies listeners
- `Complete(err error)` - transitions to completed/failed state, moves to history if successful
- `Cancel()` - calls CancelFunc if set, transitions to cancelled state
- `Duration() time.Duration` - returns elapsed or total duration
- `IsCancellable() bool` - returns true if cancellable AND active AND running > 5s

Note: UpdateProgress and Complete need to notify the registry to update listeners. Store a reference to the registry or use package-level function.
  </action>
  <verify>
`go build ./internal/operations/...` succeeds without errors
  </verify>
  <done>
Operation type exists with all fields and lifecycle methods, OperationState enum defined with 4 states
  </done>
</task>

<task type="auto">
  <name>Task 2: Create thread-safe registry singleton</name>
  <files>
    internal/operations/registry.go
  </files>
  <action>
Create `internal/operations/registry.go` with:

```go
type Listener func(op *Operation)

type Registry struct {
    mu         sync.RWMutex
    operations map[uint64]*Operation
    history    []*Operation  // Completed ops, capped at 100
    listeners  []Listener    // Called on every operation change
    nextID     uint64
}

var defaultRegistry = &Registry{
    operations: make(map[uint64]*Operation),
}
```

Implement package-level functions that delegate to defaultRegistry:
- `Start(name string, category Category, cancellable bool) *Operation` - creates operation, adds to registry, notifies listeners
- `StartWithContext(ctx context.Context, name string, category Category) (*Operation, context.Context)` - creates cancellable operation with derived context
- `Get(id uint64) *Operation` - returns operation by ID
- `ActiveCount() int` - returns count of active operations (thread-safe)
- `Active() []*Operation` - returns copy of active operations slice
- `History() []*Operation` - returns copy of history slice
- `AddListener(fn Listener)` - adds listener for operation changes

Critical threading pattern from RESEARCH.md:
```go
// BAD - holding lock during UI callback
r.mu.Lock()
defer r.mu.Unlock()
// ... update operation
for _, listener := range r.listeners {
    listener(op)  // DANGER: may call RunOnMain while locked
}

// GOOD - copy data, release lock, then notify
r.mu.Lock()
op.Progress = progress
opCopy := *op
listeners := make([]Listener, len(r.listeners))
copy(listeners, r.listeners)
r.mu.Unlock()

for _, listener := range listeners {
    async.RunOnMain(func() {
        listener(&opCopy)
    })
}
```

History management:
- When operation completes successfully, move to history
- Failed operations stay in active list (for retry)
- Cap history at 100 items, drop oldest when exceeding
  </action>
  <verify>
`go build ./internal/operations/...` succeeds
`go vet ./internal/operations/...` shows no issues
  </verify>
  <done>
Registry singleton exists with Start, Get, ActiveCount, Active, History, AddListener functions. Thread-safe with proper lock/unlock patterns that avoid deadlock with UI callbacks.
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/operations/...` succeeds
- [ ] `go vet ./internal/operations/...` shows no issues
- [ ] Operation type has all required fields (ID, Name, Category, State, StartedAt, EndedAt, Progress, Message, Cancellable, CancelFunc, Error, RetryFunc)
- [ ] Registry uses mutex for thread-safety
- [ ] Listeners are notified via async.RunOnMain (no lock held during callback)
- [ ] History is capped at 100 items
</verification>

<success_criteria>
- Operations package compiles with types and registry
- Thread-safe registry with proper deadlock avoidance pattern
- Operation lifecycle methods work (UpdateProgress, Complete, Cancel)
- Listener notification uses async.RunOnMain
</success_criteria>

<output>
After completion, create `.planning/phases/03-operations-progress/03-01-SUMMARY.md`
</output>
