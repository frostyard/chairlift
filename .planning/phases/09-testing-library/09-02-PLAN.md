---
phase: 09-testing-library
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/async/errors_test.go
  - internal/operations/registry_test.go
  - internal/operations/operation_test.go
autonomous: true

must_haves:
  truths:
    - "UserError implements error interface correctly"
    - "UserError formatting methods produce expected output"
    - "Operations registry can start, complete, and cancel operations"
    - "Operations registry maintains history correctly"
  artifacts:
    - path: "internal/async/errors_test.go"
      provides: "Unit tests for UserError type"
      min_lines: 80
    - path: "internal/operations/registry_test.go"
      provides: "Unit tests for Registry operations"
      min_lines: 60
    - path: "internal/operations/operation_test.go"
      provides: "Unit tests for Operation type and state transitions"
      min_lines: 40
  key_links:
    - from: "internal/operations/registry_test.go"
      to: "internal/async/scheduler.go"
      via: "RunOnMain callback mechanism"
      pattern: "async\\.RunOnMain"
---

<objective>
Add unit tests for async error handling and operations registry.

Purpose: Test the core infrastructure packages (async, operations) that all pages depend on. These tests ensure the callback registry, error formatting, and operation lifecycle work correctly.
Output: Test files for UserError type and operations registry with isolation patterns.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-testing-library/09-CONTEXT.md
@.planning/phases/09-testing-library/09-RESEARCH.md

Code to test:
@internal/async/errors.go
@internal/operations/registry.go
@internal/operations/operation.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserError tests</name>
  <files>internal/async/errors_test.go</files>
  <action>
Create comprehensive unit tests for the UserError type.

Test functions to add:
1. `TestUserError_Error` - Verify Error() returns Summary
2. `TestUserError_Unwrap` - Verify Unwrap() returns Technical error
3. `TestUserError_FormatForUser_SummaryOnly` - Summary without hint
4. `TestUserError_FormatForUser_WithHint` - Summary with hint formats "Summary: Hint"
5. `TestUserError_FormatWithDetails_NoTechnical` - Details without technical error
6. `TestUserError_FormatWithDetails_WithTechnical` - Details with technical error
7. `TestNewUserError` - Verify constructor sets fields
8. `TestNewUserErrorWithHint` - Verify hint constructor sets all fields

Use table-driven tests for FormatForUser variations:

```go
package async

import (
    "errors"
    "testing"
)

func TestUserError_Error(t *testing.T) {
    err := &UserError{Summary: "Couldn't install Firefox"}
    if err.Error() != "Couldn't install Firefox" {
        t.Errorf("Error() = %q, want %q", err.Error(), "Couldn't install Firefox")
    }
}

func TestUserError_Unwrap(t *testing.T) {
    underlying := errors.New("network timeout")
    err := &UserError{Technical: underlying}

    if err.Unwrap() != underlying {
        t.Error("Unwrap() did not return Technical error")
    }

    // Verify errors.Is works
    if !errors.Is(err, underlying) {
        t.Error("errors.Is should find underlying error")
    }
}

func TestUserError_FormatForUser(t *testing.T) {
    tests := map[string]struct {
        err  *UserError
        want string
    }{
        "summary only": {
            err:  &UserError{Summary: "Couldn't install Firefox"},
            want: "Couldn't install Firefox",
        },
        "with hint": {
            err:  &UserError{Summary: "Couldn't connect", Hint: "Check your internet"},
            want: "Couldn't connect: Check your internet",
        },
        "empty hint": {
            err:  &UserError{Summary: "Error", Hint: ""},
            want: "Error",
        },
    }

    for name, tc := range tests {
        t.Run(name, func(t *testing.T) {
            got := tc.err.FormatForUser()
            if got != tc.want {
                t.Errorf("FormatForUser() = %q, want %q", got, tc.want)
            }
        })
    }
}

func TestUserError_FormatWithDetails(t *testing.T) {
    tests := map[string]struct {
        err     *UserError
        contain string
    }{
        "without technical": {
            err:     &UserError{Summary: "Error"},
            contain: "Error",
        },
        "with technical": {
            err:     &UserError{Summary: "Error", Technical: errors.New("timeout")},
            contain: "Details: timeout",
        },
    }

    for name, tc := range tests {
        t.Run(name, func(t *testing.T) {
            got := tc.err.FormatWithDetails()
            if !strings.Contains(got, tc.contain) {
                t.Errorf("FormatWithDetails() = %q, want to contain %q", got, tc.contain)
            }
        })
    }
}

func TestNewUserError(t *testing.T) {
    underlying := errors.New("network error")
    err := NewUserError("Couldn't connect", underlying)

    if err.Summary != "Couldn't connect" {
        t.Errorf("Summary = %q, want %q", err.Summary, "Couldn't connect")
    }
    if err.Technical != underlying {
        t.Error("Technical not set correctly")
    }
    if err.Hint != "" {
        t.Errorf("Hint = %q, want empty", err.Hint)
    }
}

func TestNewUserErrorWithHint(t *testing.T) {
    underlying := errors.New("network error")
    err := NewUserErrorWithHint("Couldn't connect", "Check internet", underlying)

    if err.Summary != "Couldn't connect" {
        t.Errorf("Summary = %q, want %q", err.Summary, "Couldn't connect")
    }
    if err.Hint != "Check internet" {
        t.Errorf("Hint = %q, want %q", err.Hint, "Check internet")
    }
    if err.Technical != underlying {
        t.Error("Technical not set correctly")
    }
}
```

Add `"strings"` import for Contains check.
  </action>
  <verify>go test -v ./internal/async/...</verify>
  <done>UserError tests pass, covering all formatting methods and constructors</done>
</task>

<task type="auto">
  <name>Task 2: Create operations registry tests</name>
  <files>internal/operations/registry_test.go</files>
  <action>
Create unit tests for the operations Registry.

IMPORTANT: The default registry is a singleton that notifies listeners via async.RunOnMain. For isolated testing, create test-local Registry instances with direct method calls.

Test functions:
1. `TestRegistry_Start` - Verify operation is created and tracked
2. `TestRegistry_Get` - Verify operation can be retrieved by ID
3. `TestRegistry_ActiveCount` - Verify count updates correctly
4. `TestRegistry_Complete_Success` - Verify completion moves to history
5. `TestRegistry_Complete_Failure` - Verify failure keeps in active
6. `TestRegistry_Cancel` - Verify cancellation moves to history
7. `TestRegistry_HistoryCap` - Verify maxHistory limit is respected

```go
package operations

import (
    "context"
    "errors"
    "testing"
    "time"
)

// newTestRegistry creates an isolated registry for testing
func newTestRegistry() *Registry {
    return &Registry{
        operations: make(map[uint64]*Operation),
    }
}

func TestRegistry_Start(t *testing.T) {
    r := newTestRegistry()

    op := r.start("Test Operation", CategoryInstall, false, nil)

    if op.Name != "Test Operation" {
        t.Errorf("Name = %q, want %q", op.Name, "Test Operation")
    }
    if op.Category != CategoryInstall {
        t.Errorf("Category = %v, want %v", op.Category, CategoryInstall)
    }
    if op.State != StateActive {
        t.Errorf("State = %v, want %v", op.State, StateActive)
    }
    if op.Progress != -1 {
        t.Errorf("Progress = %v, want -1 (indeterminate)", op.Progress)
    }
}

func TestRegistry_Get(t *testing.T) {
    r := newTestRegistry()
    op := r.start("Test", CategoryUpdate, false, nil)

    got := r.get(op.ID)
    if got == nil {
        t.Fatal("get returned nil for existing operation")
    }
    if got.ID != op.ID {
        t.Errorf("got ID %d, want %d", got.ID, op.ID)
    }

    // Non-existent ID should return nil
    if r.get(99999) != nil {
        t.Error("get should return nil for non-existent ID")
    }
}

func TestRegistry_ActiveCount(t *testing.T) {
    r := newTestRegistry()

    if r.activeCount() != 0 {
        t.Errorf("initial activeCount = %d, want 0", r.activeCount())
    }

    r.start("Op 1", CategoryInstall, false, nil)
    if r.activeCount() != 1 {
        t.Errorf("after 1 start, activeCount = %d, want 1", r.activeCount())
    }

    r.start("Op 2", CategoryUpdate, false, nil)
    if r.activeCount() != 2 {
        t.Errorf("after 2 starts, activeCount = %d, want 2", r.activeCount())
    }
}

func TestRegistry_Complete_Success(t *testing.T) {
    r := newTestRegistry()
    op := r.start("Test", CategoryInstall, false, nil)

    r.complete(op.ID, nil) // nil error = success

    // Should be removed from active
    if r.activeCount() != 0 {
        t.Errorf("after complete, activeCount = %d, want 0", r.activeCount())
    }

    // Should be in history
    history := r.getHistory()
    if len(history) != 1 {
        t.Fatalf("history length = %d, want 1", len(history))
    }
    if history[0].State != StateCompleted {
        t.Errorf("history state = %v, want %v", history[0].State, StateCompleted)
    }
}

func TestRegistry_Complete_Failure(t *testing.T) {
    r := newTestRegistry()
    op := r.start("Test", CategoryInstall, false, nil)

    testErr := errors.New("installation failed")
    r.complete(op.ID, testErr) // non-nil error = failure

    // Failed operations stay in active list for retry
    if r.activeCount() != 1 {
        t.Errorf("after failure, activeCount = %d, want 1", r.activeCount())
    }

    // Verify state and error
    got := r.get(op.ID)
    if got.State != StateFailed {
        t.Errorf("state = %v, want %v", got.State, StateFailed)
    }
    if got.Error != testErr {
        t.Error("error not set on failed operation")
    }
}

func TestRegistry_Cancel(t *testing.T) {
    r := newTestRegistry()

    cancelled := false
    cancelFunc := func() { cancelled = true }

    op := r.start("Test", CategoryInstall, true, cancelFunc)
    r.cancel(op.ID)

    // Should call cancel func
    if !cancelled {
        t.Error("cancel func was not called")
    }

    // Should be removed from active
    if r.activeCount() != 0 {
        t.Errorf("after cancel, activeCount = %d, want 0", r.activeCount())
    }

    // Should be in history with cancelled state
    history := r.getHistory()
    if len(history) != 1 {
        t.Fatalf("history length = %d, want 1", len(history))
    }
    if history[0].State != StateCancelled {
        t.Errorf("history state = %v, want %v", history[0].State, StateCancelled)
    }
}

func TestRegistry_HistoryCap(t *testing.T) {
    r := newTestRegistry()

    // Add more than maxHistory operations and complete them
    for i := 0; i < maxHistory+10; i++ {
        op := r.start("Op", CategoryInstall, false, nil)
        r.complete(op.ID, nil)
    }

    history := r.getHistory()
    if len(history) > maxHistory {
        t.Errorf("history length = %d, exceeds maxHistory %d", len(history), maxHistory)
    }
}
```
  </action>
  <verify>go test -v ./internal/operations/...</verify>
  <done>Registry tests pass with isolated test registries, covering start/complete/cancel/history</done>
</task>

<task type="auto">
  <name>Task 3: Create operation type tests</name>
  <files>internal/operations/operation_test.go</files>
  <action>
Create unit tests for the Operation type and its methods.

Test functions:
1. `TestOperation_UpdateProgress` - Verify progress updates
2. `TestOperation_Complete` - Verify Complete() transitions state
3. `TestOperation_Cancel` - Verify Cancel() transitions state
4. `TestOperation_IsCancellable` - Verify cancellation eligibility logic
5. `TestCategory_String` - Verify category string values

```go
package operations

import (
    "testing"
    "time"
)

func TestCategory_Values(t *testing.T) {
    // Verify category constants have distinct values
    categories := []Category{CategoryInstall, CategoryUpdate, CategoryRemove, CategoryMaintenance}
    seen := make(map[Category]bool)

    for _, c := range categories {
        if seen[c] {
            t.Errorf("duplicate category value: %v", c)
        }
        seen[c] = true
    }
}

func TestState_Values(t *testing.T) {
    // Verify state constants have distinct values
    states := []State{StateActive, StateCompleted, StateFailed, StateCancelled}
    seen := make(map[State]bool)

    for _, s := range states {
        if seen[s] {
            t.Errorf("duplicate state value: %v", s)
        }
        seen[s] = true
    }
}

func TestOperation_UpdateProgress(t *testing.T) {
    r := newTestRegistry()
    op := r.start("Test", CategoryInstall, false, nil)

    // Initial progress should be -1 (indeterminate)
    if op.Progress != -1 {
        t.Errorf("initial Progress = %v, want -1", op.Progress)
    }

    // Update progress
    r.updateProgress(op.ID, 0.5, "Downloading...")

    got := r.get(op.ID)
    if got.Progress != 0.5 {
        t.Errorf("Progress = %v, want 0.5", got.Progress)
    }
    if got.Message != "Downloading..." {
        t.Errorf("Message = %q, want %q", got.Message, "Downloading...")
    }
}

func TestOperation_IsCancellable_RequiresBothConditions(t *testing.T) {
    // IsCancellable requires: Cancellable flag AND >5s runtime

    r := newTestRegistry()

    // Not cancellable flag
    op1 := r.start("Test", CategoryInstall, false, nil)
    got1 := r.get(op1.ID)
    if got1.IsCancellable() {
        t.Error("operation without Cancellable flag should not be cancellable")
    }

    // Cancellable flag but just started (< 5s)
    op2 := r.start("Test", CategoryInstall, true, nil)
    got2 := r.get(op2.ID)
    if got2.IsCancellable() {
        t.Error("operation running < 5s should not be cancellable yet")
    }
}

func TestOperation_Duration(t *testing.T) {
    r := newTestRegistry()
    op := r.start("Test", CategoryInstall, false, nil)

    // Duration for active operation
    got := r.get(op.ID)
    if got.Duration() < 0 {
        t.Error("active operation should have non-negative duration")
    }

    // Complete the operation
    r.complete(op.ID, nil)

    // Duration for completed operation uses EndedAt
    history := r.getHistory()
    if len(history) == 0 {
        t.Fatal("expected operation in history")
    }
    if history[0].Duration() < 0 {
        t.Error("completed operation should have non-negative duration")
    }
}
```

Note: These tests use newTestRegistry() helper from registry_test.go (same package).
  </action>
  <verify>go test -v ./internal/operations/...</verify>
  <done>Operation type tests pass, covering progress updates, state transitions, and cancellation logic</done>
</task>

</tasks>

<verification>
Run all new tests:
```bash
go test -v ./internal/async/... ./internal/operations/...
```

Run with race detector:
```bash
go test -race ./internal/async/... ./internal/operations/...
```
</verification>

<success_criteria>
- All UserError tests pass covering Error(), Unwrap(), FormatForUser(), FormatWithDetails()
- All Registry tests pass with isolated test registries
- All Operation tests pass covering state transitions and duration
- No race conditions detected with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/09-testing-library/09-02-SUMMARY.md`
</output>
