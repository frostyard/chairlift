---
phase: 09-testing-library
plan: 04
type: execute
wave: 3
depends_on: ["09-03"]
files_modified:
  - pkg/adwutil/widgets.go
  - pkg/adwutil/empty_state.go
  - pkg/adwutil/operations.go
  - pkg/adwutil/operation.go
  - internal/widgets/empty_state.go
  - internal/widgets/rows.go
  - internal/operations/registry.go
  - internal/operations/operation.go
autonomous: true

must_haves:
  truths:
    - "Widget helpers (NewEmptyState, NewLinkRow, NewButtonRow) are in adwutil"
    - "Operations tracking (Registry, Operation) is in adwutil"
    - "Internal packages re-export from adwutil"
    - "Library has no chairlift internal imports"
  artifacts:
    - path: "pkg/adwutil/widgets.go"
      provides: "Row helper functions (NewLinkRow, NewButtonRow, etc.)"
      min_lines: 100
    - path: "pkg/adwutil/empty_state.go"
      provides: "NewEmptyState helper"
      min_lines: 30
    - path: "pkg/adwutil/operations.go"
      provides: "Operations registry"
      min_lines: 150
    - path: "pkg/adwutil/operation.go"
      provides: "Operation type and state constants"
      min_lines: 80
  key_links:
    - from: "internal/widgets/rows.go"
      to: "pkg/adwutil/widgets.go"
      via: "re-export wrappers"
      pattern: "adwutil\\."
    - from: "internal/operations/registry.go"
      to: "pkg/adwutil/operations.go"
      via: "re-export wrappers"
      pattern: "adwutil\\."
---

<objective>
Extract widgets and operations packages to pkg/adwutil library.

Purpose: Complete the library extraction by moving widget helpers and operations tracking to pkg/adwutil, making the full toolkit reusable.
Output: Complete adwutil library with widgets and operations, internal packages as thin re-export wrappers.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-testing-library/09-CONTEXT.md
@.planning/phases/09-testing-library/09-RESEARCH.md

Prior plan summary (if exists):
@.planning/phases/09-testing-library/09-03-SUMMARY.md

Code to extract:
@internal/widgets/empty_state.go
@internal/widgets/rows.go
@internal/operations/registry.go
@internal/operations/operation.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract widgets to adwutil</name>
  <files>
pkg/adwutil/widgets.go
pkg/adwutil/empty_state.go
  </files>
  <action>
Move widget helpers to pkg/adwutil.

1. Create pkg/adwutil/empty_state.go:

```go
// Package adwutil provides reusable GTK4/Libadwaita patterns.
//
// This file provides empty state display helpers.
package adwutil

import (
    "github.com/jwijenbergh/puregotk/v4/adw"
)

// EmptyStateConfig configures an empty state display.
type EmptyStateConfig struct {
    Title       string
    Description string
    IconName    string
    Compact     bool // For inline use in expanders/popovers
}

// NewEmptyState creates a StatusPage configured for empty state display.
//
// StatusPage is the GNOME HIG-recommended widget for showing empty states.
//
// Common icon names:
//   - "folder-symbolic" for empty file/folder lists
//   - "emblem-synchronizing-symbolic" for empty operations
//   - "document-open-recent-symbolic" for empty history
//   - "package-x-generic-symbolic" for empty package lists
//
// Must be called from the GTK main thread.
func NewEmptyState(cfg EmptyStateConfig) *adw.StatusPage {
    status := adw.NewStatusPage()
    status.SetTitle(cfg.Title)
    status.SetDescription(cfg.Description)
    if cfg.IconName != "" {
        status.SetIconName(cfg.IconName)
    }
    if cfg.Compact {
        status.AddCssClass("compact")
    }
    return status
}
```

2. Create pkg/adwutil/widgets.go:

```go
// Package adwutil provides reusable GTK4/Libadwaita patterns.
//
// This file provides helper functions for common widget patterns.
package adwutil

import (
    "sync"

    "github.com/jwijenbergh/puregotk/v4/adw"
    "github.com/jwijenbergh/puregotk/v4/gtk"
)

// signalCallbackRegistry stores signal callbacks to prevent GC collection.
var (
    signalCallbackMu sync.Mutex
    signalCallbacks  = make(map[uintptr]any)
    signalCallbackID uintptr
)

// storeSignalCallback saves a callback to prevent GC and returns its ID.
func storeSignalCallback(cb any) uintptr {
    signalCallbackMu.Lock()
    defer signalCallbackMu.Unlock()
    signalCallbackID++
    signalCallbacks[signalCallbackID] = cb
    return signalCallbackID
}

// NewLinkRow creates an ActionRow that triggers an action when activated.
//
// The row has an external link icon suffix, suitable for "open URL" patterns.
//
// Must be called from the GTK main thread.
func NewLinkRow(title, subtitle string, onClick func()) *adw.ActionRow {
    row := adw.NewActionRow()
    row.SetTitle(title)
    row.SetSubtitle(subtitle)

    btn := gtk.NewButtonFromIconName("adw-external-link-symbolic")
    btn.SetValign(gtk.AlignCenterValue)
    btn.AddCssClass("flat")
    btn.SetTooltipText("Open link")

    cb := func(_ gtk.Button) {
        onClick()
    }
    storeSignalCallback(cb)
    btn.ConnectClicked(&cb)

    row.AddSuffix(&btn.Widget)
    return row
}

// NewInfoRow creates a simple ActionRow for displaying information.
//
// The row is not activatable - just title and subtitle.
// Suitable for read-only information in preference groups.
//
// Must be called from the GTK main thread.
func NewInfoRow(title, subtitle string) *adw.ActionRow {
    row := adw.NewActionRow()
    row.SetTitle(title)
    row.SetSubtitle(subtitle)
    return row
}

// NewButtonRow creates an ActionRow with an action button suffix.
//
// The button uses "suggested-action" CSS class (blue/accent color).
// Use [NewButtonRowWithClass] for different button styles.
//
// Must be called from the GTK main thread.
func NewButtonRow(title, subtitle, buttonLabel string, onClick func()) *adw.ActionRow {
    return NewButtonRowWithClass(title, subtitle, buttonLabel, "suggested-action", onClick)
}

// NewButtonRowWithClass creates an ActionRow with a styled button suffix.
//
// Common CSS classes:
//   - "suggested-action": Blue/accent colored for primary actions
//   - "destructive-action": Red colored for dangerous actions
//
// Must be called from the GTK main thread.
func NewButtonRowWithClass(title, subtitle, buttonLabel, cssClass string, onClick func()) *adw.ActionRow {
    row := adw.NewActionRow()
    row.SetTitle(title)
    row.SetSubtitle(subtitle)

    btn := gtk.NewButtonWithLabel(buttonLabel)
    btn.SetValign(gtk.AlignCenterValue)
    btn.AddCssClass(cssClass)

    cb := func(_ gtk.Button) {
        onClick()
    }
    storeSignalCallback(cb)
    btn.ConnectClicked(&cb)

    row.AddSuffix(&btn.Widget)
    return row
}

// NewIconRow creates an ActionRow with a prefix icon.
//
// Common icon names:
//   - "dialog-error-symbolic": Error indicator
//   - "dialog-warning-symbolic": Warning indicator
//   - "object-select-symbolic": Checkmark for selected items
//
// Must be called from the GTK main thread.
func NewIconRow(title, subtitle, iconName string) *adw.ActionRow {
    row := adw.NewActionRow()
    row.SetTitle(title)
    row.SetSubtitle(subtitle)

    icon := gtk.NewImageFromIconName(iconName)
    row.AddPrefix(&icon.Widget)

    return row
}
```

IMPORTANT: Only allowed imports:
- sync
- github.com/jwijenbergh/puregotk/v4/adw
- github.com/jwijenbergh/puregotk/v4/gtk

NO imports from github.com/frostyard/chairlift/internal/...
  </action>
  <verify>go build ./pkg/adwutil/...</verify>
  <done>Widget helpers extracted to adwutil, package compiles</done>
</task>

<task type="auto">
  <name>Task 2: Extract operations to adwutil</name>
  <files>
pkg/adwutil/operation.go
pkg/adwutil/operations.go
  </files>
  <action>
Move operations tracking to pkg/adwutil.

1. Create pkg/adwutil/operation.go with types:

```go
// Package adwutil provides reusable GTK4/Libadwaita patterns.
//
// This file defines the Operation type for tracking async operations.
package adwutil

import (
    "context"
    "sync/atomic"
    "time"
)

// Category represents the type of operation.
type Category int

const (
    CategoryInstall Category = iota
    CategoryUpdate
    CategoryRemove
    CategoryMaintenance
)

// State represents the current state of an operation.
type State int

const (
    StateActive State = iota
    StateCompleted
    StateFailed
    StateCancelled
)

// Operation represents a trackable async operation.
type Operation struct {
    ID          uint64
    Name        string
    Category    Category
    State       State
    StartedAt   time.Time
    EndedAt     time.Time
    Progress    float64 // -1 for indeterminate
    Message     string
    Error       error
    Cancellable bool
    CancelFunc  context.CancelFunc
    RetryFunc   func()

    registry *Registry // Back-reference for method calls
}

// operationID is the atomic counter for unique operation IDs.
var operationID uint64

// nextOperationID returns the next unique operation ID.
func nextOperationID() uint64 {
    return atomic.AddUint64(&operationID, 1)
}

// Duration returns how long the operation has been running or ran.
func (o *Operation) Duration() time.Duration {
    if o.EndedAt.IsZero() {
        return time.Since(o.StartedAt)
    }
    return o.EndedAt.Sub(o.StartedAt)
}

// IsCancellable returns whether the operation can be cancelled.
// Requires Cancellable flag AND >5s runtime.
func (o *Operation) IsCancellable() bool {
    if !o.Cancellable {
        return false
    }
    return o.Duration() > 5*time.Second
}

// UpdateProgress updates the operation's progress and message.
func (o *Operation) UpdateProgress(progress float64, message string) {
    if o.registry != nil {
        o.registry.updateProgress(o.ID, progress, message)
    }
}

// Complete marks the operation as completed or failed.
func (o *Operation) Complete(err error) {
    if o.registry != nil {
        o.registry.complete(o.ID, err)
    }
}

// Cancel cancels the operation.
func (o *Operation) Cancel() {
    if o.registry != nil {
        o.registry.cancel(o.ID)
    }
}
```

2. Create pkg/adwutil/operations.go with registry:

```go
// Package adwutil provides reusable GTK4/Libadwaita patterns.
//
// This file provides the operations registry for tracking async operations.
package adwutil

import (
    "context"
    "sync"
    "time"
)

// Listener is a callback function that receives operation updates.
type Listener func(op *Operation)

// Registry tracks all active and completed operations.
type Registry struct {
    mu         sync.RWMutex
    operations map[uint64]*Operation
    history    []*Operation
    listeners  []Listener
}

// MaxHistory is the maximum number of completed operations to keep.
const MaxHistory = 100

// DefaultRegistry is the singleton registry instance.
var DefaultRegistry = NewRegistry()

// NewRegistry creates a new operations registry.
func NewRegistry() *Registry {
    return &Registry{
        operations: make(map[uint64]*Operation),
    }
}

// Start creates a new operation and adds it to the default registry.
func Start(name string, category Category, cancellable bool) *Operation {
    return DefaultRegistry.Start(name, category, cancellable)
}

// StartWithContext creates a cancellable operation with a derived context.
func StartWithContext(ctx context.Context, name string, category Category) (*Operation, context.Context) {
    return DefaultRegistry.StartWithContext(ctx, name, category)
}

// Get returns the operation with the given ID from the default registry.
func Get(id uint64) *Operation {
    return DefaultRegistry.Get(id)
}

// ActiveCount returns the number of active operations in the default registry.
func ActiveCount() int {
    return DefaultRegistry.ActiveCount()
}

// Active returns a copy of all active operations from the default registry.
func Active() []*Operation {
    return DefaultRegistry.Active()
}

// History returns a copy of the completed operations history.
func History() []*Operation {
    return DefaultRegistry.History()
}

// AddListener adds a listener to the default registry.
func AddListener(fn Listener) {
    DefaultRegistry.AddListener(fn)
}

// Start creates a new operation and adds it to the registry.
func (r *Registry) Start(name string, category Category, cancellable bool) *Operation {
    return r.start(name, category, cancellable, nil)
}

// StartWithContext creates a cancellable operation with a derived context.
func (r *Registry) StartWithContext(ctx context.Context, name string, category Category) (*Operation, context.Context) {
    derivedCtx, cancel := context.WithCancel(ctx)
    op := r.start(name, category, true, cancel)
    return op, derivedCtx
}

// Get returns the operation with the given ID.
func (r *Registry) Get(id uint64) *Operation {
    r.mu.RLock()
    defer r.mu.RUnlock()
    return r.operations[id]
}

// ActiveCount returns the number of active operations.
func (r *Registry) ActiveCount() int {
    r.mu.RLock()
    defer r.mu.RUnlock()
    return len(r.operations)
}

// Active returns a copy of all active operations.
func (r *Registry) Active() []*Operation {
    r.mu.RLock()
    defer r.mu.RUnlock()

    ops := make([]*Operation, 0, len(r.operations))
    for _, op := range r.operations {
        opCopy := *op
        ops = append(ops, &opCopy)
    }
    return ops
}

// History returns a copy of the completed operations.
func (r *Registry) History() []*Operation {
    r.mu.RLock()
    defer r.mu.RUnlock()

    history := make([]*Operation, len(r.history))
    for i, op := range r.history {
        opCopy := *op
        history[i] = &opCopy
    }
    return history
}

// AddListener adds a listener that will be called for operation changes.
func (r *Registry) AddListener(fn Listener) {
    r.mu.Lock()
    defer r.mu.Unlock()
    r.listeners = append(r.listeners, fn)
}

// start is the internal implementation.
func (r *Registry) start(name string, category Category, cancellable bool, cancelFunc context.CancelFunc) *Operation {
    op := &Operation{
        ID:          nextOperationID(),
        Name:        name,
        Category:    category,
        State:       StateActive,
        StartedAt:   time.Now(),
        Progress:    -1,
        Cancellable: cancellable,
        CancelFunc:  cancelFunc,
        registry:    r,
    }

    r.mu.Lock()
    r.operations[op.ID] = op
    opCopy := *op
    listeners := make([]Listener, len(r.listeners))
    copy(listeners, r.listeners)
    r.mu.Unlock()

    r.notifyListeners(&opCopy, listeners)
    return op
}

func (r *Registry) updateProgress(id uint64, progress float64, message string) {
    r.mu.Lock()
    op, ok := r.operations[id]
    if !ok || op.State != StateActive {
        r.mu.Unlock()
        return
    }

    op.Progress = progress
    op.Message = message
    opCopy := *op
    listeners := make([]Listener, len(r.listeners))
    copy(listeners, r.listeners)
    r.mu.Unlock()

    r.notifyListeners(&opCopy, listeners)
}

func (r *Registry) complete(id uint64, err error) {
    r.mu.Lock()
    op, ok := r.operations[id]
    if !ok || op.State != StateActive {
        r.mu.Unlock()
        return
    }

    op.EndedAt = time.Now()
    op.Error = err

    if err != nil {
        op.State = StateFailed
    } else {
        op.State = StateCompleted
        delete(r.operations, id)
        r.addToHistory(op)
    }

    opCopy := *op
    listeners := make([]Listener, len(r.listeners))
    copy(listeners, r.listeners)
    r.mu.Unlock()

    r.notifyListeners(&opCopy, listeners)
}

func (r *Registry) cancel(id uint64) {
    r.mu.Lock()
    op, ok := r.operations[id]
    if !ok || op.State != StateActive {
        r.mu.Unlock()
        return
    }

    if op.CancelFunc != nil {
        op.CancelFunc()
    }

    op.State = StateCancelled
    op.EndedAt = time.Now()
    delete(r.operations, id)
    r.addToHistory(op)

    opCopy := *op
    listeners := make([]Listener, len(r.listeners))
    copy(listeners, r.listeners)
    r.mu.Unlock()

    r.notifyListeners(&opCopy, listeners)
}

func (r *Registry) addToHistory(op *Operation) {
    r.history = append(r.history, op)
    if len(r.history) > MaxHistory {
        r.history = r.history[len(r.history)-MaxHistory:]
    }
}

func (r *Registry) notifyListeners(op *Operation, listeners []Listener) {
    for _, listener := range listeners {
        fn := listener
        RunOnMain(func() {
            fn(op)
        })
    }
}
```

Note: Uses RunOnMain from same package (no import needed).
  </action>
  <verify>go build ./pkg/adwutil/...</verify>
  <done>Operations extracted to adwutil, package compiles</done>
</task>

<task type="auto">
  <name>Task 3: Update internal packages to re-export from adwutil</name>
  <files>
internal/widgets/empty_state.go
internal/widgets/rows.go
internal/operations/registry.go
internal/operations/operation.go
  </files>
  <action>
Update internal packages to re-export from pkg/adwutil for backward compatibility.

1. Update internal/widgets/empty_state.go:

```go
// Package widgets provides reusable GTK4/Libadwaita widget components.
//
// This package re-exports functionality from pkg/adwutil for backward compatibility.
package widgets

import (
    "github.com/frostyard/chairlift/pkg/adwutil"
    "github.com/jwijenbergh/puregotk/v4/adw"
)

// EmptyStateConfig is an alias for [adwutil.EmptyStateConfig].
type EmptyStateConfig = adwutil.EmptyStateConfig

// NewEmptyState creates a StatusPage configured for empty state display.
// See [adwutil.NewEmptyState] for full documentation.
func NewEmptyState(cfg EmptyStateConfig) *adw.StatusPage {
    return adwutil.NewEmptyState(cfg)
}
```

2. Update internal/widgets/rows.go to re-export:

```go
// Package widgets provides reusable GTK4/Libadwaita widget components.
//
// This package re-exports functionality from pkg/adwutil for backward compatibility.
package widgets

import (
    "github.com/frostyard/chairlift/pkg/adwutil"
    "github.com/jwijenbergh/puregotk/v4/adw"
)

// NewLinkRow creates an ActionRow that triggers an action when activated.
// See [adwutil.NewLinkRow] for full documentation.
func NewLinkRow(title, subtitle string, onClick func()) *adw.ActionRow {
    return adwutil.NewLinkRow(title, subtitle, onClick)
}

// NewInfoRow creates a simple ActionRow for displaying information.
// See [adwutil.NewInfoRow] for full documentation.
func NewInfoRow(title, subtitle string) *adw.ActionRow {
    return adwutil.NewInfoRow(title, subtitle)
}

// NewButtonRow creates an ActionRow with an action button suffix.
// See [adwutil.NewButtonRow] for full documentation.
func NewButtonRow(title, subtitle, buttonLabel string, onClick func()) *adw.ActionRow {
    return adwutil.NewButtonRow(title, subtitle, buttonLabel, onClick)
}

// NewButtonRowWithClass creates an ActionRow with a styled button suffix.
// See [adwutil.NewButtonRowWithClass] for full documentation.
func NewButtonRowWithClass(title, subtitle, buttonLabel, cssClass string, onClick func()) *adw.ActionRow {
    return adwutil.NewButtonRowWithClass(title, subtitle, buttonLabel, cssClass, onClick)
}

// NewIconRow creates an ActionRow with a prefix icon.
// See [adwutil.NewIconRow] for full documentation.
func NewIconRow(title, subtitle, iconName string) *adw.ActionRow {
    return adwutil.NewIconRow(title, subtitle, iconName)
}
```

3. Update internal/operations/registry.go to re-export:

```go
// Package operations provides async operation tracking for the UI.
//
// This package re-exports functionality from pkg/adwutil for backward compatibility.
package operations

import (
    "context"

    "github.com/frostyard/chairlift/pkg/adwutil"
)

// Listener is an alias for [adwutil.Listener].
type Listener = adwutil.Listener

// Registry is an alias for [adwutil.Registry].
type Registry = adwutil.Registry

// maxHistory uses the library constant.
const maxHistory = adwutil.MaxHistory

// defaultRegistry uses the library default.
var defaultRegistry = adwutil.DefaultRegistry

// Start creates a new operation.
func Start(name string, category Category, cancellable bool) *Operation {
    return adwutil.Start(name, adwutil.Category(category), cancellable)
}

// StartWithContext creates a cancellable operation with a derived context.
func StartWithContext(ctx context.Context, name string, category Category) (*Operation, context.Context) {
    return adwutil.StartWithContext(ctx, name, adwutil.Category(category))
}

// Get returns the operation with the given ID.
func Get(id uint64) *Operation {
    return adwutil.Get(id)
}

// ActiveCount returns the number of active operations.
func ActiveCount() int {
    return adwutil.ActiveCount()
}

// Active returns a copy of all active operations.
func Active() []*Operation {
    return adwutil.Active()
}

// History returns a copy of the completed operations history.
func History() []*Operation {
    return adwutil.History()
}

// AddListener adds a listener.
func AddListener(fn Listener) {
    adwutil.AddListener(fn)
}
```

4. Update internal/operations/operation.go to re-export:

```go
// Package operations provides async operation tracking for the UI.
//
// This package re-exports types from pkg/adwutil for backward compatibility.
package operations

import "github.com/frostyard/chairlift/pkg/adwutil"

// Category is an alias for [adwutil.Category].
type Category = adwutil.Category

// Category constants.
const (
    CategoryInstall     = adwutil.CategoryInstall
    CategoryUpdate      = adwutil.CategoryUpdate
    CategoryRemove      = adwutil.CategoryRemove
    CategoryMaintenance = adwutil.CategoryMaintenance
)

// State is an alias for [adwutil.State].
type State = adwutil.State

// State constants.
const (
    StateActive    = adwutil.StateActive
    StateCompleted = adwutil.StateCompleted
    StateFailed    = adwutil.StateFailed
    StateCancelled = adwutil.StateCancelled
)

// Operation is an alias for [adwutil.Operation].
type Operation = adwutil.Operation

// nextID uses the library function.
func nextID() uint64 {
    // This is internal - the library generates IDs automatically
    return 0
}
```

Note: The re-export pattern uses type aliases (`type X = adwutil.X`) so the types are identical.
  </action>
  <verify>go build ./... && go test ./internal/...</verify>
  <done>Internal packages re-export from adwutil, full application compiles and tests pass</done>
</task>

</tasks>

<verification>
Verify library has no internal imports:
```bash
go list -f '{{.Imports}}' ./pkg/adwutil/... | grep "frostyard/chairlift/internal" && echo "ERROR: internal imports found" || echo "Clean - no internal imports"
```

Run all tests:
```bash
go test -v ./pkg/adwutil/... ./internal/...
```

Verify full application compiles and runs:
```bash
go build ./... && ./chairlift --help
```
</verification>

<success_criteria>
- pkg/adwutil has widgets.go, empty_state.go, operations.go, operation.go
- pkg/adwutil has NO imports from internal/ packages
- internal/widgets re-exports from adwutil
- internal/operations re-exports from adwutil
- Full application compiles
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-testing-library/09-04-SUMMARY.md`
</output>
