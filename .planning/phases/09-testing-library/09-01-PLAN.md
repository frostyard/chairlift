---
phase: 09-testing-library
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/pages/updates/logic_test.go
  - internal/pages/applications/logic_test.go
  - internal/config/config_test.go
  - internal/config/testdata/valid.yml
  - internal/config/testdata/minimal.yml
autonomous: true

must_haves:
  truths:
    - "Updates logic layer functions have unit tests"
    - "Applications logic layer functions have unit tests"
    - "Config parsing works correctly for valid YAML files"
    - "Config parsing handles edge cases gracefully"
  artifacts:
    - path: "internal/pages/updates/logic_test.go"
      provides: "Unit tests for UpdateCounts, IsNBCAvailable"
      min_lines: 30
    - path: "internal/pages/applications/logic_test.go"
      provides: "Unit tests for GetSidebarItems, SearchResult"
      min_lines: 40
    - path: "internal/config/config_test.go"
      provides: "Unit tests for config parsing and lookup"
      min_lines: 60
    - path: "internal/config/testdata/valid.yml"
      provides: "Test fixture for valid config"
    - path: "internal/config/testdata/minimal.yml"
      provides: "Test fixture for minimal config"
  key_links:
    - from: "internal/config/config_test.go"
      to: "internal/config/testdata/"
      via: "LoadFromPath with test fixtures"
      pattern: "loadFromPath.*testdata"
---

<objective>
Add unit tests for page logic layers (updates, applications) and config package.

Purpose: Establish test coverage for pure Go logic functions that have no GTK dependencies, enabling confident future refactoring.
Output: Test files for updates logic, applications logic, and config parsing with test fixtures.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-testing-library/09-CONTEXT.md
@.planning/phases/09-testing-library/09-RESEARCH.md

Existing test patterns:
@internal/pages/help/logic_test.go
@internal/pages/system/logic_test.go

Logic layers to test:
@internal/pages/updates/logic.go
@internal/pages/applications/logic.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create updates logic tests</name>
  <files>internal/pages/updates/logic_test.go</files>
  <action>
Create unit tests for the updates logic layer following the established pattern from help/logic_test.go.

Test functions to add:
1. `TestUpdateCounts_Total` - Verify Total() returns sum of NBC + Flatpak + Homebrew
2. `TestUpdateCounts_TotalEmpty` - Verify Total() returns 0 for empty counts
3. `TestIsNBCAvailable` - Verify it returns without panic (like system logic test)

Pattern to follow:
```go
package updates

import "testing"

func TestUpdateCounts_Total(t *testing.T) {
    counts := UpdateCounts{NBC: 1, Flatpak: 2, Homebrew: 3}
    if counts.Total() != 6 {
        t.Errorf("Total() = %d, want 6", counts.Total())
    }
}
```

Do NOT test CheckNBCUpdate, CountFlatpakUpdates, CountHomebrewOutdated - they call external services.
  </action>
  <verify>go test -v ./internal/pages/updates/...</verify>
  <done>Updates logic tests pass, covering UpdateCounts.Total() and IsNBCAvailable()</done>
</task>

<task type="auto">
  <name>Task 2: Create applications logic tests</name>
  <files>internal/pages/applications/logic_test.go</files>
  <action>
Create unit tests for the applications logic layer.

Test functions to add:
1. `TestPMCategory_Constants` - Verify category constants have expected values
2. `TestSidebarItem_Fields` - Verify SidebarItem struct fields are accessible
3. `TestSearchResult_Fields` - Verify SearchResult struct fields are accessible
4. `TestHasSearchCapability_ReturnsWithoutPanic` - Verify function doesn't panic

Note: GetSidebarItems() calls pm.FlatpakIsInstalled() etc., so we test it returns a non-empty slice but don't assert specific values (they depend on installed PMs).

Pattern:
```go
package applications

import "testing"

func TestPMCategory_Constants(t *testing.T) {
    // Verify constants have expected values
    if CategoryAll != "all" {
        t.Errorf("CategoryAll = %q, want %q", CategoryAll, "all")
    }
    if CategoryFlatpak != "flatpak" {
        t.Errorf("CategoryFlatpak = %q, want %q", CategoryFlatpak, "flatpak")
    }
    // ... etc
}

func TestGetSidebarItems_ReturnsItems(t *testing.T) {
    items := GetSidebarItems()
    if len(items) == 0 {
        t.Error("GetSidebarItems() returned empty slice")
    }
    // First item should always be "All Applications"
    if items[0].Category != CategoryAll {
        t.Errorf("first item Category = %q, want %q", items[0].Category, CategoryAll)
    }
}
```
  </action>
  <verify>go test -v ./internal/pages/applications/...</verify>
  <done>Applications logic tests pass, covering category constants and sidebar items</done>
</task>

<task type="auto">
  <name>Task 3: Create config tests with fixtures</name>
  <files>
internal/config/config_test.go
internal/config/testdata/valid.yml
internal/config/testdata/minimal.yml
  </files>
  <action>
Create unit tests for config parsing with test fixtures.

1. Create testdata directory and fixtures:

testdata/valid.yml - Full config with all pages:
```yaml
system_page:
  system_info_group:
    enabled: true
  nbc_status_group:
    enabled: true
help_page:
  help_resources_group:
    enabled: true
    website: "https://example.com"
    issues: "https://github.com/example/issues"
```

testdata/minimal.yml - Minimal valid config:
```yaml
system_page:
  system_info_group:
    enabled: false
```

2. Create config_test.go with tests:

```go
package config

import (
    "os"
    "path/filepath"
    "testing"
)

func TestLoadFromPath_ValidConfig(t *testing.T) {
    cfg, err := loadFromPath("testdata/valid.yml")
    if err != nil {
        t.Fatalf("loadFromPath failed: %v", err)
    }

    // Verify expected structure
    group := cfg.SystemPage["system_info_group"]
    if !group.Enabled {
        t.Error("system_info_group should be enabled")
    }
}

func TestLoadFromPath_MinimalConfig(t *testing.T) {
    cfg, err := loadFromPath("testdata/minimal.yml")
    if err != nil {
        t.Fatalf("loadFromPath failed: %v", err)
    }

    group := cfg.SystemPage["system_info_group"]
    if group.Enabled {
        t.Error("system_info_group should be disabled")
    }
}

func TestLoadFromPath_NonExistent(t *testing.T) {
    _, err := loadFromPath("testdata/nonexistent.yml")
    if err == nil {
        t.Error("expected error for nonexistent file")
    }
}

func TestIsGroupEnabled_Defaults(t *testing.T) {
    cfg := defaultConfig()

    // Should return true for enabled groups
    if !cfg.IsGroupEnabled("system_page", "system_info_group") {
        t.Error("system_info_group should be enabled by default")
    }

    // Should return true for unknown groups (default behavior)
    if !cfg.IsGroupEnabled("unknown_page", "unknown_group") {
        t.Error("unknown groups should default to enabled")
    }
}

func TestGetGroupConfig_ReturnsConfig(t *testing.T) {
    cfg, _ := loadFromPath("testdata/valid.yml")

    group := cfg.GetGroupConfig("help_page", "help_resources_group")
    if group == nil {
        t.Fatal("expected non-nil group config")
    }
    if group.Website != "https://example.com" {
        t.Errorf("Website = %q, want %q", group.Website, "https://example.com")
    }
}

func TestGetGroupConfig_ReturnsNilForUnknown(t *testing.T) {
    cfg := defaultConfig()

    group := cfg.GetGroupConfig("help_page", "nonexistent_group")
    if group != nil {
        t.Error("expected nil for nonexistent group")
    }
}
```

Note: loadFromPath is unexported, so tests must be in the same package.
  </action>
  <verify>go test -v ./internal/config/...</verify>
  <done>Config tests pass, covering loadFromPath, IsGroupEnabled, GetGroupConfig with fixtures</done>
</task>

</tasks>

<verification>
Run all new tests:
```bash
go test -v ./internal/pages/updates/... ./internal/pages/applications/... ./internal/config/...
```

Verify coverage improvement:
```bash
go test -cover ./internal/...
```
</verification>

<success_criteria>
- All new tests pass with `go test -v`
- Updates logic has tests for UpdateCounts.Total() and IsNBCAvailable()
- Applications logic has tests for constants and GetSidebarItems()
- Config has tests for parsing, IsGroupEnabled, and GetGroupConfig
- Test fixtures exist in testdata/ directories
</success_criteria>

<output>
After completion, create `.planning/phases/09-testing-library/09-01-SUMMARY.md`
</output>
