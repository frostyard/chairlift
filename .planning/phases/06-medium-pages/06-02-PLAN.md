---
phase: 06-medium-pages
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/pages/extensions/logic.go
  - internal/pages/extensions/logic_test.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "Extensions logic layer imports updex library directly"
    - "No subprocess/CLI calls to updex command"
    - "Progress reporting uses pm/progress interface"
    - "Logic layer is testable without GTK"
  artifacts:
    - path: "internal/pages/extensions/logic.go"
      provides: "updex client wrapper, typed results"
      contains: "updex.NewClient"
    - path: "internal/pages/extensions/logic_test.go"
      provides: "Tests for logic layer"
      contains: "func Test"
    - path: "go.mod"
      provides: "updex library dependency"
      contains: "github.com/frostyard/updex"
  key_links:
    - from: "internal/pages/extensions/logic.go"
      to: "github.com/frostyard/updex/updex"
      via: "direct library import"
      pattern: "updex\\.NewClient"
    - from: "internal/pages/extensions/logic.go"
      to: "github.com/frostyard/pm/progress"
      via: "progress reporter interface"
      pattern: "progress\\.ProgressReporter"
---

<objective>
Create Extensions logic layer with direct updex library integration, replacing CLI wrapper.

Purpose: INTG-01 requirement - updex functionality uses the Go library directly instead of CLI wrapper.
Output: extensions/logic.go with updex.Client integration, logic_test.go with tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-medium-pages/06-CONTEXT.md
@.planning/phases/06-medium-pages/06-RESEARCH.md

# Current CLI wrapper to replace
@internal/updex/updex.go

# Pattern to follow for progress reporting
@internal/pm/wrapper.go

# Established page patterns
@internal/pages/help/logic.go
@internal/pages/system/logic.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updex library dependency</name>
  <files>go.mod</files>
  <action>
Add the updex library as a direct dependency.

Run:
```bash
go get github.com/frostyard/updex@latest
go mod tidy
```

This brings in:
- `github.com/frostyard/updex/updex` - The client SDK
- `github.com/frostyard/pm/progress` - Progress reporting interface (already used by pm package)

**Verify the library is available:**
```go
import "github.com/frostyard/updex/updex"

client := updex.NewClient(updex.ClientConfig{})
```
  </action>
  <verify>`go mod tidy` succeeds; `go list -m github.com/frostyard/updex` shows version</verify>
  <done>go.mod contains github.com/frostyard/updex dependency</done>
</task>

<task type="auto">
  <name>Task 2: Create extensions logic layer with updex library</name>
  <files>internal/pages/extensions/logic.go, internal/pages/extensions/logic_test.go</files>
  <action>
Create pure Go logic layer for extensions page with direct updex library integration. NO GTK imports.

**logic.go:**

```go
package extensions

import (
    "context"
    "github.com/frostyard/pm/progress"
    "github.com/frostyard/updex/updex"
)

// ExtensionInfo represents an installed extension for UI display
type ExtensionInfo struct {
    Component string
    Version   string
    Current   bool
}

// DiscoveredExtension represents an available extension from a repository
type DiscoveredExtension struct {
    Name     string
    Versions []string
}

// Client wraps updex.Client for the extensions page
type Client struct {
    client *updex.Client
}

// NewClient creates a new extensions client
func NewClient() *Client {
    return &Client{
        client: updex.NewClient(updex.ClientConfig{}),
    }
}

// NewClientWithProgress creates a client with progress reporting
func NewClientWithProgress(reporter progress.ProgressReporter) *Client {
    return &Client{
        client: updex.NewClient(updex.ClientConfig{
            Progress: reporter,
        }),
    }
}

// IsAvailable checks if the extensions system is available
// (systemd-sysext support present)
func (c *Client) IsAvailable() bool {
    // Check for /var/lib/extensions directory or library availability
    return c.client.IsAvailable()
}

// ListInstalled returns installed extensions grouped by component
func (c *Client) ListInstalled(ctx context.Context) ([]ExtensionInfo, error) {
    versions, err := c.client.List(ctx, updex.ListOptions{})
    if err != nil {
        return nil, err
    }
    
    var extensions []ExtensionInfo
    for _, v := range versions {
        if v.Installed {
            extensions = append(extensions, ExtensionInfo{
                Component: v.Component,
                Version:   v.Version,
                Current:   v.Current,
            })
        }
    }
    return extensions, nil
}

// Discover finds available extensions from a repository URL
func (c *Client) Discover(ctx context.Context, repoURL string) ([]DiscoveredExtension, error) {
    result, err := c.client.Discover(ctx, repoURL)
    if err != nil {
        return nil, err
    }
    
    var discovered []DiscoveredExtension
    for _, ext := range result.Extensions {
        discovered = append(discovered, DiscoveredExtension{
            Name:     ext.Name,
            Versions: ext.Versions,
        })
    }
    return discovered, nil
}

// Install installs an extension from a repository
func (c *Client) Install(ctx context.Context, repoURL, component string) error {
    return c.client.Install(ctx, updex.InstallOptions{
        URL:       repoURL,
        Component: component,
    })
}
```

**logic_test.go:**

Test the logic layer with mock interfaces where possible. Since updex.Client is a struct, tests may be integration-style or verify the wrapper types:

```go
package extensions

import (
    "testing"
)

func TestExtensionInfo(t *testing.T) {
    ext := ExtensionInfo{
        Component: "mesa",
        Version:   "24.1.0",
        Current:   true,
    }
    
    if ext.Component != "mesa" {
        t.Errorf("expected component 'mesa', got %s", ext.Component)
    }
}

func TestDiscoveredExtension(t *testing.T) {
    ext := DiscoveredExtension{
        Name:     "steam",
        Versions: []string{"1.0.0", "0.9.0"},
    }
    
    if len(ext.Versions) != 2 {
        t.Errorf("expected 2 versions, got %d", len(ext.Versions))
    }
}

func TestNewClient(t *testing.T) {
    // Verify client creation doesn't panic
    client := NewClient()
    if client == nil {
        t.Error("expected non-nil client")
    }
}
```

**Key points from RESEARCH.md:**
- Use updex.ClientConfig{Progress: reporter} for progress callbacks
- Client methods return typed results, not raw library types
- This replaces internal/updex/updex.go CLI wrapper entirely
  </action>
  <verify>`go build ./internal/pages/extensions/...` succeeds with no GTK imports; `go test ./internal/pages/extensions/...` passes</verify>
  <done>logic.go wraps updex.Client with typed results; logic_test.go has basic tests</done>
</task>

</tasks>

<verification>
1. `go mod tidy` - no missing dependencies
2. `go build ./internal/pages/extensions/...` - compiles successfully
3. `go test ./internal/pages/extensions/...` - tests pass
4. Verify no os/exec calls to "updex" in logic.go
5. Verify logic.go imports github.com/frostyard/updex/updex
</verification>

<success_criteria>
- go.mod contains updex library dependency
- extensions/logic.go uses updex.NewClient directly
- No subprocess/CLI calls to updex command
- Logic layer has no GTK imports
- Tests pass without GTK runtime
</success_criteria>

<output>
After completion, create `.planning/phases/06-medium-pages/06-02-SUMMARY.md`
</output>
