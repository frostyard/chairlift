---
phase: 01-async-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/async/scheduler.go
  - internal/async/errors.go
autonomous: true

must_haves:
  truths:
    - "RunOnMain() function exists and can schedule callbacks on GTK main thread"
    - "UserError type separates user-facing summary from technical details"
    - "Callback registry prevents garbage collection of scheduled callbacks"
  artifacts:
    - path: "internal/async/scheduler.go"
      provides: "Thread-safe RunOnMain() function with callback registry"
      exports: ["RunOnMain"]
      min_lines: 30
    - path: "internal/async/errors.go"
      provides: "UserError type for structured user-friendly errors"
      exports: ["UserError"]
      min_lines: 25
  key_links:
    - from: "internal/async/scheduler.go"
      to: "glib.IdleAdd"
      via: "GTK main thread scheduling"
      pattern: "glib\\.IdleAdd"
---

<objective>
Create the internal/async package with core utilities for thread-safe GTK updates and user-friendly error handling.

Purpose: This package consolidates the runOnMainThread pattern currently duplicated in userhome.go and wrapper.go into a single, well-documented implementation. It also introduces the UserError type for consistent error messaging per CONTEXT.md decisions.

Output: Two new files in internal/async/ providing the foundation for all async operations in Chairlift.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-async-foundation/01-CONTEXT.md
@.planning/phases/01-async-foundation/01-RESEARCH.md
@internal/views/userhome.go (lines 28-55 for existing pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create async/scheduler.go with RunOnMain()</name>
  <files>internal/async/scheduler.go</files>
  <action>
Create the internal/async package directory and scheduler.go file.

Implement RunOnMain() following the EXACT pattern from userhome.go lines 36-55:
- Package-level callback registry (map[uintptr]func()) protected by sync.Mutex
- Incrementing uintptr callback ID
- Lock/unlock sequence: lock -> increment ID -> store callback -> unlock -> then call glib.IdleAdd
- SourceFunc callback that: locks -> retrieves and deletes callback -> unlocks -> executes callback
- Return false from SourceFunc to remove source after execution

Export only:
- `func RunOnMain(fn func())` - The single entry point for goroutine-to-UI updates

Add package documentation explaining:
- This is the ONLY safe way to update UI from goroutines
- Why the callback registry exists (prevents GC collection)
- When to use: any widget update from a non-main goroutine

Do NOT add any additional features beyond RunOnMain() - keep it minimal for this phase.
  </action>
  <verify>
- File exists at internal/async/scheduler.go
- `go build ./...` succeeds
- `go vet ./internal/async/...` passes
- Package has proper documentation
  </verify>
  <done>
- RunOnMain() is exported and matches the proven userhome.go pattern exactly
- Package compiles without errors or warnings
  </done>
</task>

<task type="auto">
  <name>Task 2: Create async/errors.go with UserError type</name>
  <files>internal/async/errors.go</files>
  <action>
Create errors.go in the internal/async package.

Implement UserError type per RESEARCH.md pattern:
```go
type UserError struct {
    Summary   string // User-facing summary: "Couldn't install Firefox"
    Hint      string // Optional action hint: "Check your internet connection"
    Technical error  // Original error for logging/debugging
}
```

Implement methods:
- `Error() string` - Returns Summary (satisfies error interface)
- `Unwrap() error` - Returns Technical (enables errors.Is/As)
- `FormatForUser() string` - Returns "Summary: Hint" or just "Summary" if no Hint
- `FormatWithDetails() string` - Returns user message + technical details for expandable view

Follow CONTEXT.md tone decisions:
- Use "Couldn't" not "Failed to" or "Error:"
- Keep summaries short and action-oriented

Add helper constructor:
- `func NewUserError(summary string, technical error) *UserError` - Creates error with just summary
- `func NewUserErrorWithHint(summary, hint string, technical error) *UserError` - Creates error with hint

Add package documentation explaining when to use UserError vs plain errors.
  </action>
  <verify>
- File exists at internal/async/errors.go
- `go build ./...` succeeds
- `go vet ./internal/async/...` passes
- UserError satisfies error interface
  </verify>
  <done>
- UserError type is exported with all four methods
- Helper constructors NewUserError and NewUserErrorWithHint are exported
- Package compiles without errors
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Build verification:
   ```bash
   go build ./...
   ```

2. Vet verification:
   ```bash
   go vet ./internal/async/...
   ```

3. Visual inspection:
   - internal/async/scheduler.go exists with RunOnMain
   - internal/async/errors.go exists with UserError
   - Both files have proper package documentation

4. Pattern verification:
   - RunOnMain uses callback registry pattern (not naked glib.IdleAdd)
   - UserError implements error interface via Error() method
</verification>

<success_criteria>
- [ ] internal/async/scheduler.go exists with exported RunOnMain()
- [ ] internal/async/errors.go exists with exported UserError type
- [ ] `go build ./...` passes
- [ ] `go vet ./internal/async/...` passes
- [ ] Package documentation present on both files
</success_criteria>

<output>
After completion, create `.planning/phases/01-async-foundation/01-01-SUMMARY.md` using the summary template.
</output>
