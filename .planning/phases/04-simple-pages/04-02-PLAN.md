---
phase: 04-simple-pages
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/pages/system/page.go
  - internal/pages/system/logic.go
autonomous: true

must_haves:
  truths:
    - "System page builds and displays system info, NBC status, and health link"
    - "Goroutines are cancelled when page is destroyed"
    - "System page logic is testable without GTK runtime"
  artifacts:
    - path: "internal/pages/system/page.go"
      provides: "SystemPage struct with constructor, context-based goroutine management"
      contains: "context.WithCancel"
    - path: "internal/pages/system/logic.go"
      provides: "Pure Go logic for parsing os-release and checking NBC availability"
      contains: "func ParseOSRelease"
  key_links:
    - from: "internal/pages/system/page.go"
      to: "internal/pages/page.go"
      via: "implements Page interface"
      pattern: "pages\\.Deps"
    - from: "internal/pages/system/page.go"
      to: "internal/nbc"
      via: "fetches NBC status"
      pattern: "nbc\\.GetStatus"
    - from: "internal/pages/system/page.go"
      to: "p.ctx.Done()"
      via: "goroutine cancellation"
      pattern: "p\\.ctx\\.Done\\(\\)|p\\.ctx\\.Err\\(\\)"
---

<objective>
Create the System page package with proper goroutine lifecycle management.

Purpose: Extract the System page from userhome.go, demonstrating the full page pattern including async data loading with context-based cancellation.

Output: `internal/pages/system/` package with working System page implementation and testable logic.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-simple-pages/04-RESEARCH.md

@internal/views/userhome.go (lines 236-423 for buildSystemPage, loadOSRelease, loadNBCStatus)
@internal/pages/page.go (from 04-01)
@internal/nbc/nbc.go
@internal/widgets/async_expander.go
@internal/widgets/rows.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create System page logic layer</name>
  <files>internal/pages/system/logic.go</files>
  <action>
Create `internal/pages/system/logic.go` with pure Go business logic:

1. Package declaration: `package system`

2. Imports: bufio, os, strings, context, golang.org/x/text/cases, golang.org/x/text/language, internal/nbc

3. `OSReleaseEntry` struct:
   - `Key string` - raw key (e.g., "PRETTY_NAME")
   - `Value string` - parsed value
   - `DisplayKey string` - human-readable key (e.g., "Pretty Name")
   - `IsURL bool` - true if key ends with "URL"

4. `ParseOSRelease() ([]OSReleaseEntry, error)` function:
   - Opens `/etc/os-release`
   - Scans line by line, skips empty lines and comments
   - Parses KEY=VALUE format, handles quoted values
   - Calls `formatKey()` for DisplayKey
   - Sets IsURL based on key suffix
   - Returns entries slice

5. `formatKey(key string) string` private function:
   - Replaces underscores with spaces
   - Uses `cases.Title(language.English).String(strings.ToLower(readable))`
   - Matches the pattern in userhome.go loadOSRelease

6. `IsNBCAvailable() bool` function:
   - Checks if `/run/nbc-booted` exists via os.Stat
   - Returns true if exists, false otherwise

7. `FetchNBCStatus(ctx context.Context) (*nbc.Status, error)` function:
   - Simple wrapper calling `nbc.GetStatus(ctx)`
   - Enables testing by allowing mock injection

This logic has no GTK dependencies, only stdlib and existing internal packages.
  </action>
  <verify>
`go build ./internal/pages/system/...` succeeds
  </verify>
  <done>
`internal/pages/system/logic.go` exists with ParseOSRelease, IsNBCAvailable, FetchNBCStatus functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create System page UI layer</name>
  <files>internal/pages/system/page.go</files>
  <action>
Create `internal/pages/system/page.go` implementing the Page interface:

1. Package declaration and imports (context, fmt, adw, gtk, async, config, nbc, pages, widgets)

2. `Page` struct with fields:
   - `toolbarView *adw.ToolbarView`
   - `prefsPage *adw.PreferencesPage`
   - `config *config.Config`
   - `toaster pages.Toaster`
   - `launchApp func(string)` - callback for launching apps
   - `openURL func(string)` - callback for opening URLs
   - `ctx context.Context` - for goroutine lifecycle
   - `cancel context.CancelFunc` - to cancel goroutines on Destroy

3. `New(deps pages.Deps, launchApp, openURL func(string)) *Page` constructor:
   - Creates context with cancel: `ctx, cancel := context.WithCancel(context.Background())`
   - Creates Page struct
   - Calls `p.buildUI()`
   - Returns the page

4. `Widget() *adw.ToolbarView` method - returns toolbarView

5. `Destroy()` method:
   - Calls `p.cancel()` if not nil
   - This cancels all goroutines started by this page

6. `buildUI()` private method:
   - Creates ToolbarView with HeaderBar
   - Creates ScrolledWindow with PreferencesPage
   - Calls build methods for each group

7. `buildSystemInfoGroup()` private method:
   - Check config.IsGroupEnabled("system_page", "system_info_group")
   - Create PreferencesGroup, add expander row
   - Call loadOSRelease synchronously (it's fast, file read)

8. `loadOSRelease(expander *adw.ExpanderRow)` private method:
   - Call `ParseOSRelease()` from logic.go
   - On error, add "Not available" row
   - For each entry, create ActionRow with title=DisplayKey, subtitle=Value
   - If IsURL, make activatable with external link icon and openURL callback
   - IMPORTANT: Capture URL in local variable before closure

9. `buildNBCStatusGroup()` private method:
   - Check `IsNBCAvailable()` from logic.go, return if false
   - Check config.IsGroupEnabled("system_page", "nbc_status_group")
   - Create PreferencesGroup
   - Create `widgets.NewAsyncExpanderRow("NBC Status Details", "Loading...")`
   - Add to page
   - Call `p.loadNBCStatus(expander)` to start async load

10. `loadNBCStatus(expander *widgets.AsyncExpanderRow)` private method:
    - Call `expander.StartLoading("Fetching NBC status")`
    - Start goroutine:
      - Create context with timeout: `ctx, cancel := context.WithTimeout(p.ctx, nbc.DefaultTimeout)`
      - Call `FetchNBCStatus(ctx)` from logic.go
      - Check `p.ctx.Done()` before UI update - if cancelled, return early
      - Call `async.RunOnMain(func() { ... })`:
        - Check `p.ctx.Err() != nil` again before UI update
        - On error: `expander.SetError(...)`
        - On success: `expander.SetContent("Loaded")`, add info rows for each field
    - Pattern matches userhome.go loadNBCStatus but with context checks

11. `buildSystemHealthGroup()` private method:
    - Check config.IsGroupEnabled("system_page", "health_group")
    - Get group config, extract appID (default "io.missioncenter.MissionCenter")
    - Create `widgets.NewLinkRow(...)` with launchApp callback
    - Add to page

Follow exact patterns from userhome.go but with context-based cancellation in all goroutines.
  </action>
  <verify>
`go build ./internal/pages/system/...` succeeds
  </verify>
  <done>
`internal/pages/system/page.go` exists with Page struct, context-based goroutine management, and all three groups
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/pages/system/...` compiles successfully
- [ ] logic.go has no GTK imports (verify with `grep -l "puregotk" internal/pages/system/logic.go` returns nothing)
- [ ] page.go uses `context.WithCancel` in constructor
- [ ] page.go calls `p.cancel()` in Destroy()
- [ ] page.go checks `p.ctx.Done()` or `p.ctx.Err()` before UI updates in goroutines
</verification>

<success_criteria>
- System page package exists at `internal/pages/system/`
- System page implements pages.Page interface
- Goroutines use page context for cancellation
- Business logic is separated from UI code
</success_criteria>

<output>
After completion, create `.planning/phases/04-simple-pages/04-02-SUMMARY.md`
</output>
