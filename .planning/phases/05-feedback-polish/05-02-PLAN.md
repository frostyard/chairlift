---
phase: 05-feedback-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/window/window.go
  - internal/views/userhome.go
autonomous: true

must_haves:
  truths:
    - "Dry-run mode shows persistent banner at top of window"
    - "Banner is dismissible or has action button"
    - "Failed operations can be retried via retry button"
  artifacts:
    - path: "internal/window/window.go"
      provides: "Dry-run mode banner"
      contains: "adw.NewBanner"
    - path: "internal/views/userhome.go"
      provides: "RetryFunc wiring for operations"
      contains: "RetryFunc"
  key_links:
    - from: "internal/window/window.go"
      to: "internal/pm/wrapper.go"
      via: "pm.IsDryRun() check"
      pattern: "pm\\.IsDryRun"
---

<objective>
Add dry-run mode banner to window and ensure operations have RetryFunc wired for retry capability.

Purpose: Users need clear visual indication when in dry-run mode, and failed operations should be retryable without restarting the app.
Output: Persistent banner for dry-run mode, validated retry functionality.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-feedback-polish/05-RESEARCH.md

@internal/window/window.go
@internal/views/userhome.go
@internal/operations/popover.go
@internal/pm/wrapper.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dry-run banner to window</name>
  <files>internal/window/window.go</files>
  <action>
Modify internal/window/window.go to add a persistent banner for dry-run mode:

1. Add import for "github.com/frostyard/chairlift/internal/pm"

2. Add field to Window struct:
   ```go
   dryRunBanner *adw.Banner
   ```

3. In buildUI(), after creating progressSheet and before toasts:
   - Create the banner:
   ```go
   w.dryRunBanner = adw.NewBanner("Dry-Run Mode: Changes will be simulated only")
   w.dryRunBanner.SetRevealed(pm.IsDryRun())
   ```

4. Modify the widget hierarchy in buildUI():
   - Current: toasts.SetChild(&progressSheet.Widget)
   - New: Create a vertical box that contains banner + progressSheet:
   ```go
   // Create content box for banner + main content
   contentBox := gtk.NewBox(gtk.OrientationVerticalValue, 0)
   contentBox.Append(&w.dryRunBanner.Widget)
   contentBox.Append(&progressSheet.Widget)
   
   // Set as toast overlay child
   w.toasts.SetChild(&contentBox.Widget)
   ```

5. The banner is persistent (no dismiss button) since dry-run is a command-line flag that can't be changed at runtime. The banner text makes it clear this is informational.

Note: pm.IsDryRun() is checked once at window creation. Since dry-run is set via command-line flag before the window is created, this is sufficient.
  </action>
  <verify>Run app with `--dry-run` flag and verify banner appears at top: `go run . --dry-run`</verify>
  <done>Dry-run mode shows persistent banner at window top, banner not shown in normal mode</done>
</task>

<task type="auto">
  <name>Task 2: Validate RetryFunc wiring in operations</name>
  <files>internal/views/userhome.go</files>
  <action>
Review and ensure RetryFunc is properly wired for retryable operations in userhome.go.

The retry button is already implemented in operations/popover.go (lines 264-280). This task ensures operations set RetryFunc when started.

1. Find the "Update Homebrew" operation (search for StartTrackedOperation or "Update Homebrew"):
   - Verify it has a pattern similar to:
   ```go
   var doUpdate func()
   doUpdate = func() {
       op, done := operations.StartTrackedOperation(...)
       op.RetryFunc = doUpdate  // Self-reference for retry
       go func() {
           err := pm.HomebrewUpdate()
           async.RunOnMain(func() {
               done()
               op.Complete(err)
           })
       }()
   }
   doUpdate()
   ```

2. If RetryFunc is not set, add it following the pattern above.

3. Search for other long-running operations that might benefit from retry:
   - Look for operations.Start or operations.StartTrackedOperation calls
   - For any that don't have RetryFunc set, consider if retry makes sense
   - At minimum, document which operations support retry

4. If the pattern is already in place, document what exists. If changes needed, make them.

Note: Per Phase 3 decisions, failed operations stay in active list for retry. The RetryFunc should be a self-referential function that starts a new operation.
  </action>
  <verify>
1. `go build ./...` succeeds
2. Run app, trigger an operation that might fail (e.g., update with no network)
3. Verify "Retry" button appears in operations popover for failed operation
  </verify>
  <done>At least one operation (Update Homebrew) has RetryFunc wired for retry capability</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go vet ./...` passes
3. App runs with `--dry-run` shows banner
4. App runs without `--dry-run` shows no banner
5. Failed operations show Retry button in popover
</verification>

<success_criteria>
- Dry-run banner visible when running with --dry-run flag
- Banner not visible in normal mode
- Failed operations show Retry button
- Clicking Retry dismisses failed operation and starts new attempt
</success_criteria>

<output>
After completion, create `.planning/phases/05-feedback-polish/05-02-SUMMARY.md`
</output>
