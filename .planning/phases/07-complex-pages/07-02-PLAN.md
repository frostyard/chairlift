---
phase: 07-complex-pages
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/pages/applications/logic.go
  - internal/pages/applications/page.go
autonomous: true

must_haves:
  truths:
    - "User can see sidebar with PM categories (All, Flatpak, Homebrew, Snap)"
    - "User can click sidebar item to filter content"
    - "Unavailable PMs show in sidebar but indicate not installed"
    - "Page structure follows established page pattern"
  artifacts:
    - path: "internal/pages/applications/logic.go"
      provides: "PM availability checks and data types"
      contains: "func Is.*Installed"
    - path: "internal/pages/applications/page.go"
      provides: "Applications page with NavigationSplitView sidebar"
      exports: ["New", "Page"]
  key_links:
    - from: "internal/pages/applications/page.go"
      to: "internal/pm"
      via: "pm.*IsInstalled availability checks"
      pattern: "pm\\.(Flatpak|Homebrew|Snap)IsInstalled"
---

<objective>
Create the Applications page foundation with sidebar navigation using AdwNavigationSplitView.

Purpose: The Applications page needs a sidebar for PM navigation (per CONTEXT.md decision). This plan establishes the page structure and sidebar. Plan 03 will add the content sections.

Output: Applications page package with sidebar navigation structure, PM availability logic, and content area placeholder.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-complex-pages/07-CONTEXT.md
@.planning/phases/07-complex-pages/07-RESEARCH.md

# Existing page patterns
@internal/pages/page.go
@internal/pages/system/page.go

# NavigationSplitView usage
@internal/window/window.go

# PM availability
@internal/pm/wrapper.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create applications logic layer</name>
  <files>internal/pages/applications/logic.go</files>
  <action>
Create the logic layer for the applications page with no GTK dependencies:

1. Define PM category type:
   ```go
   type PMCategory string
   const (
       CategoryAll      PMCategory = "all"
       CategoryFlatpak  PMCategory = "flatpak"
       CategoryHomebrew PMCategory = "homebrew"
       CategorySnap     PMCategory = "snap"
   )
   ```

2. Define sidebar item struct:
   ```go
   type SidebarItem struct {
       Category    PMCategory
       Label       string
       IconName    string
       IsInstalled bool
   }
   ```

3. Create function to get available sidebar items:
   ```go
   func GetSidebarItems() []SidebarItem {
       return []SidebarItem{
           {CategoryAll, "All Applications", "package-x-generic-symbolic", true},
           {CategoryFlatpak, "Flatpak", "application-x-flatpak-symbolic", pm.FlatpakIsInstalled()},
           {CategoryHomebrew, "Homebrew", "package-x-generic-symbolic", pm.HomebrewIsInstalled()},
           {CategorySnap, "Snap", "package-x-generic-symbolic", pm.SnapIsInstalled()},
       }
   }
   ```

4. Add package documentation comment.

Note: Keep this layer minimal. More logic will be added in Plan 03 for search and package operations.
  </action>
  <verify>
`go build ./internal/pages/applications/...` succeeds.
`grep -c "github.com/jwijenbergh/puregotk" internal/pages/applications/logic.go` returns 0.
  </verify>
  <done>logic.go exists with PM categories and sidebar item definitions, no GTK imports.</done>
</task>

<task type="auto">
  <name>Task 2: Create applications page with sidebar navigation</name>
  <files>internal/pages/applications/page.go</files>
  <action>
Create the Applications page UI with AdwNavigationSplitView for sidebar:

1. Define Page struct with:
   - toolbarView *adw.ToolbarView (outer container returned by Widget())
   - splitView *adw.NavigationSplitView
   - sidebarList *gtk.ListBox
   - contentStack *gtk.Stack (to switch between PM views)
   - currentCategory PMCategory
   - config, toaster from pages.Deps
   - ctx, cancel for goroutine lifecycle
   - Callbacks: launchApp func(string), openURL func(string)

2. Constructor New(deps pages.Deps, launchApp, openURL func(string)) *Page:
   - Create context with cancel
   - Store dependencies and callbacks
   - Call buildUI()
   - Return page

3. Implement Page interface:
   - Widget() *adw.ToolbarView - returns toolbarView
   - Destroy() - cancel context

4. Build main UI structure in buildUI():
   ```go
   func (p *Page) buildUI() {
       p.toolbarView = adw.NewToolbarView()

       // Create NavigationSplitView for sidebar layout
       p.splitView = adw.NewNavigationSplitView()
       p.splitView.SetSidebarWidthFraction(0.25)
       p.splitView.SetMinSidebarWidth(180)
       p.splitView.SetMaxSidebarWidth(280)

       // Build sidebar
       sidebarPage := p.buildSidebar()
       p.splitView.SetSidebar(sidebarPage)

       // Build content area
       contentPage := p.buildContent()
       p.splitView.SetContent(contentPage)

       p.toolbarView.SetContent(&p.splitView.Widget)
   }
   ```

5. Build sidebar with ListBox:
   ```go
   func (p *Page) buildSidebar() *adw.NavigationPage {
       toolbarView := adw.NewToolbarView()

       headerBar := adw.NewHeaderBar()
       headerBar.SetShowEndTitleButtons(false)
       toolbarView.AddTopBar(&headerBar.Widget)

       scrolled := gtk.NewScrolledWindow()
       scrolled.SetPolicy(gtk.PolicyNeverValue, gtk.PolicyAutomaticValue)
       scrolled.SetVexpand(true)

       p.sidebarList = gtk.NewListBox()
       p.sidebarList.SetSelectionMode(gtk.SelectionSingleValue)
       p.sidebarList.AddCssClass("navigation-sidebar")

       // Add sidebar items
       items := GetSidebarItems()
       for _, item := range items {
           p.addSidebarRow(item)
       }

       // Connect row-activated signal
       rowActivatedCb := func(listbox gtk.ListBox, rowPtr uintptr) {
           row := gtk.ListBoxRowNewFromInternalPtr(rowPtr)
           p.onSidebarRowActivated(*row)
       }
       p.sidebarList.ConnectRowActivated(&rowActivatedCb)

       // Select first row by default
       if first := p.sidebarList.GetRowAtIndex(0); first != nil {
           p.sidebarList.SelectRow(first)
       }

       scrolled.SetChild(&p.sidebarList.Widget)
       toolbarView.SetContent(&scrolled.Widget)

       return adw.NewNavigationPage(&toolbarView.Widget, "Categories")
   }
   ```

6. Add sidebar row helper:
   ```go
   func (p *Page) addSidebarRow(item SidebarItem) {
       row := gtk.NewListBoxRow()

       box := gtk.NewBox(gtk.OrientationHorizontalValue, 12)
       box.SetMarginTop(8)
       box.SetMarginBottom(8)
       box.SetMarginStart(12)
       box.SetMarginEnd(12)

       icon := gtk.NewImageFromIconName(item.IconName)
       box.Append(&icon.Widget)

       label := gtk.NewLabel(item.Label)
       label.SetHexpand(true)
       label.SetXalign(0)
       box.Append(&label.Widget)

       // Show "Not installed" indicator if PM unavailable
       if !item.IsInstalled && item.Category != CategoryAll {
           dimLabel := gtk.NewLabel("Not installed")
           dimLabel.AddCssClass("dim-label")
           box.Append(&dimLabel.Widget)
           row.SetSensitive(false)
       }

       row.SetChild(&box.Widget)
       // Store category in row name for lookup
       row.SetName(string(item.Category))

       p.sidebarList.Append(&row.Widget)
   }
   ```

7. Build content area (placeholder for now - Plan 03 adds sections):
   ```go
   func (p *Page) buildContent() *adw.NavigationPage {
       toolbarView := adw.NewToolbarView()

       headerBar := adw.NewHeaderBar()
       toolbarView.AddTopBar(&headerBar.Widget)

       scrolled := gtk.NewScrolledWindow()
       scrolled.SetPolicy(gtk.PolicyNeverValue, gtk.PolicyAutomaticValue)
       scrolled.SetVexpand(true)

       // Stack to hold different category views
       p.contentStack = gtk.NewStack()
       p.contentStack.SetTransitionType(gtk.StackTransitionTypeCrossfadeValue)

       // Add placeholder page for each category
       // (Plan 03 will replace these with real content)
       for _, cat := range []PMCategory{CategoryAll, CategoryFlatpak, CategoryHomebrew, CategorySnap} {
           page := adw.NewPreferencesPage()
           placeholder := adw.NewPreferencesGroup()
           placeholder.SetTitle(string(cat) + " content")
           placeholder.SetDescription("Loading...")
           page.Add(placeholder)
           p.contentStack.AddNamed(&page.Widget, string(cat))
       }

       // Show "all" by default
       p.contentStack.SetVisibleChildName(string(CategoryAll))
       p.currentCategory = CategoryAll

       scrolled.SetChild(&p.contentStack.Widget)
       toolbarView.SetContent(&scrolled.Widget)

       return adw.NewNavigationPage(&toolbarView.Widget, "Applications")
   }
   ```

8. Handle sidebar selection:
   ```go
   func (p *Page) onSidebarRowActivated(row gtk.ListBoxRow) {
       category := PMCategory(row.GetName())
       if category == p.currentCategory {
           return
       }
       p.currentCategory = category
       p.contentStack.SetVisibleChildName(string(category))
   }
   ```

Note: Content sections (Flatpak apps, Homebrew, Snap, search) will be added in Plan 03.
  </action>
  <verify>
`go build ./internal/pages/applications/...` succeeds.
`grep -c "NavigationSplitView" internal/pages/applications/page.go` returns 1 or more.
  </verify>
  <done>Applications page package exists with sidebar navigation using NavigationSplitView, implementing pages.Page interface.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate applications page into userhome.go</name>
  <files>internal/views/userhome.go</files>
  <action>
Integrate the new applications page package into userhome.go (partial integration - content in Plan 03):

1. Add import: `"github.com/frostyard/chairlift/internal/pages/applications"`

2. Add field to UserHome struct:
   - `applicationsPagePkg *applications.Page`

3. Modify New() constructor:
   - Create applications page: `uh.applicationsPagePkg = applications.New(deps, uh.launchApp, uh.openURL)`
   - Get widget: `uh.applicationsPage = uh.applicationsPagePkg.Widget()`
   - Remove the line `uh.applicationsPage, uh.applicationsPrefsPage = uh.createPage()`
   - Keep `uh.buildApplicationsPage()` for now (will be removed in Plan 03)

4. Remove from UserHome struct:
   - `applicationsPrefsPage *adw.PreferencesPage` (no longer needed)

5. Update TODO comment to include applications page in Destroy() example.

6. Verify GetPage("applications") still works (returns uh.applicationsPage).

Note: The existing buildApplicationsPage() and related methods remain for now. Plan 03 will migrate them into the applications package and remove them from userhome.go.
  </action>
  <verify>
`go build ./...` succeeds.
Run application: Applications page shows sidebar with PM categories.
  </verify>
  <done>Applications page foundation integrated, sidebar navigation visible, ready for Plan 03 to add content.</done>
</task>

</tasks>

<verification>
1. `go build ./...` - Application compiles
2. Run application: Navigate to Applications page
3. Verify: Sidebar shows "All Applications", "Flatpak", "Homebrew", "Snap"
4. Verify: Unavailable PMs show "Not installed" and are disabled
5. Verify: Clicking sidebar items switches content area (placeholder for now)
6. Verify: Sidebar uses AdwNavigationSplitView with proper width constraints
</verification>

<success_criteria>
- Applications page exists in internal/pages/applications/ with logic.go and page.go
- Page uses AdwNavigationSplitView for sidebar navigation
- Sidebar shows PM categories with availability indicators
- Page implements pages.Page interface (Widget, Destroy)
- No GTK imports in logic.go
- Content area has stack placeholder (Plan 03 adds real content)
</success_criteria>

<output>
After completion, create `.planning/phases/07-complex-pages/07-02-SUMMARY.md`
</output>
